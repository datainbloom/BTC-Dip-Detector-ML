# app.py
import os, pandas as pd, joblib, streamlit as st
from core import fetch_snapshot, load_state, save_state, tiers_to_send, format_alert_email, send_email
from monthly_forecast import get_dip_risk
import re
import datetime as dt

st.set_page_config(page_title="BTC Dips â€” Live & ML", layout="centered")
st.title("BTC Dip Alerts â€” Live & ML")

tab_live, tab_ml = st.tabs(["ðŸ“‰ Live Monitor", "ðŸ§  ML Prediction"])

# ---- LIVE MONITOR ----
with tab_live:
    snap = fetch_snapshot()
    c1, c2, c3 = st.columns(3)
    c1.metric("Price (USD)", f"${snap['price']:,.2f}")
    c2.metric("24h Change", f"{snap['pct24']:.2f}%")
    c3.metric("24h Range", f"${snap['low24']:.0f} â€” ${snap['high24']:,.0f}")
    st.caption(f"Updated: {snap['ts']}")

    # Simulator for testing (teacher can see you tested!)
    sim = st.slider("Simulate 24h % change (testing only)", -30.0, 30.0, value=None, step=0.1, format="%.1f")
    if sim is not None:
        snap["pct24"] = float(sim)
        st.info(f"Simulating pct24 = {sim:.2f}%")

    state = load_state()
    st.write("Already alerted tiers (today):", state.get("sent_tiers", []))

    to_send = tiers_to_send(snap["pct24"], state.get("sent_tiers", []))
    if to_send:
        st.warning(f"Tier {to_send[0]:.0f}% JUST hit (24h change {snap['pct24']:.2f}%).")

    colA, colB = st.columns(2)
    if colA.button("Send test email"):
        subj, html, text = format_alert_email(snap, tier=0.0, ml_note=None)
        try:
            send_email("[TEST] " + subj, html, text)
            st.success("Test email sent.")
        except Exception as e:
            st.error(f"Email error: {e}")

    if to_send and colB.button(f"Send real alert ({to_send[0]:.0f}%)"):
        t = to_send[0]
        subj, html, text = format_alert_email(snap, tier=t, ml_note=None)
        try:
            send_email(subj, html, text)
            state.setdefault("sent_tiers", []).append(t)
            state.setdefault("log", []).append({"ts": snap["ts"], "tier": t, "pct24": snap["pct24"], "price": snap["price"]})
            state["last_price"] = snap["price"]
            save_state(state)
            st.success("Alert sent and state updated.")
        except Exception as e:
            st.error(f"Email error: {e}")

    st.subheader("Alert log")
    log = state.get("log", [])
    if log:
        st.dataframe(pd.DataFrame(log))
    else:
        st.write("No alerts yet.")


# ---- ML PREDICTION (monthly_forecast.get_dip_risk) ----
with tab_ml:
    st.subheader("ðŸ§  Machine Learning Prediction")
    st.markdown(
        """
        Forecast of a â‰¥20% Bitcoin dip in the next **30 days**, generated by a
        trained **Random Forest (scikit-learn)** model on recent market indicators.
        """
    )
    st.caption("âš¡ Powered by Random Forest â€” Built with Scikit-Learn")

    try:
        with st.spinner("Computing next-30-day dip risk..."):
            msg = get_dip_risk()  # e.g. "Risk of dip in the next 30 days is: 82.00%"

        # Always show the exact message first
        st.success(msg)

        # Try to pull out a % from the message for nicer UI
        m = re.search(r'(\d+(?:\.\d+)?)\s*%', str(msg))
        risk_pct = float(m.group(1)) if m else None

        # Optional: display as a metric + risk band
        if risk_pct is not None:
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Estimated Dip Probability (30 days)", f"{risk_pct:.2f}%")
            # Simple banding for UX (tweak thresholds if you prefer)
            if risk_pct >= 70:
                lvl, badge = "High", "ðŸ”´"
            elif risk_pct >= 40:
                lvl, badge = "Medium", "ðŸŸ "
            else:
                lvl, badge = "Low", "ðŸŸ¢"
            with col2:
                st.metric("Risk Level", f"{badge} {lvl}")
            with col3:
                st.metric("Alert Threshold", "50% (configurable)")  # change if you use a different threshold

        # Model details (kept generic but informative)
        with st.expander("Model details & methodology"):
            st.markdown(
                """
                **Algorithm:** Random Forest (ensemble of decision trees, majority vote).  
                **Target event:** A drawdown of **â‰¥20%** within the next **30 days**.  
                **Feature set (examples used at inference):**
                - `current_price`  
                - `market_cap`  
                - `total_volume`  
                - `price_change_percentage_24h`  
                - `high_24h`, `low_24h`

                **How to interpret the probability:**
                - **0â€“39%** â†’ Low risk (ðŸŸ¢): No alert by default  
                - **40â€“69%** â†’ Medium risk (ðŸŸ ): Keep an eye on momentum & volume  
                - **70â€“100%** â†’ High risk (ðŸ”´): Consider risk management actions  
                
                **Notes:**  
                - The model uses recent market indicators and historical BTC data to estimate the likelihood
                  of a â‰¥20% drawdown in a 30-day window.  
                - Probabilities are estimates, not guarantees; they can shift with new data.  
                """
            )

        # Timestamp
        st.caption(f"Last updated: {dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

      # send alert with the exact ML message
        if st.button("Send alert with ML note"):
            try:
                subj, html, text = format_alert_email(
                    snap if 'snap' in locals() else {},
                    tier=0.0,
                    ml_note=risk_pct if risk_pct is not None else msg
                )
                send_email("[ML NOTE] " + subj, html, text)
                st.success("Email sent with ML probability/details.")
            except Exception as e:
                st.warning(f"Alert email failed: {e}")

    except Exception as e:
        st.error("Error while running get_dip_risk().")
        st.exception(e)

